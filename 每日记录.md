## 2022-3-14

参加了牛客的华为研发工程师编程题，熟悉了下写题的黑盒模式（自己负责管理输入输出、导入各种库）。写了3道题，都写出来了。


不足之处有

> 1.优先级队列 priority_queue的英文拼写老是忘记。使用的声明为 priority_queue<int,vector<int>,greater<int>>;

> 2.算法的头忘了。 #algorithm

***
解决的3道题

#### 1.某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。
小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。

解决思路：设一个变量num记录当前空瓶数，设一个变量res记录最终答案（初始化为0）。

```c++
while(num >2){  
	res+=num/3;  
	num = num/3 + num%3;  
}
```

当循环结束，如果num=2时，res++（因为可以向老板借一瓶）  

#### 2.明明生成了N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。

解决思路：第一反应就是用哈希表+优先级队列去解决。哈希表保证数据的唯一性，用优先级队列保证数据的有序性

#### 3.写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

解决思路： 因为输入的都是一个形如0xAA的字符串，只需要写一个for循环从字符串的尾部开始，转换成十进制并累计即可。
```c++
for(int i = size-1;i>=2;i--){
	if(str[i] == 'A'){
		res += (pow(16,count)*10);//这里不用傻乎乎的写5个if，直接-55就行了
	}
	else if(str[i] == 'B'){
		res += (pow(16,count)*11);
	}
	else if(str[i] == 'C'){
		res += (pow(16,count)*12);
	}
	else if(str[i] == 'D'){
		res += (pow(16,count)*13);
	}
	else if(str[i] == 'E'){
		res += (pow(16,count)*14);
	}
	else if(str[i] == 'F'){
		res += (pow(16,count)*15);
	}
	else{
		int num = (int)(str[i]-'0');//这里一定要记得-‘0’
		res += (pow(16,count)*num);
	}
	count++;
}
```
***
#### 力扣每日一题599. 两个列表的最小索引总和

假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
	
解决思路：还是哈希表一下子就解出来了。不用思考的题

***
看视频摆烂了会儿。开始自己手写十大排序算法，写了冒泡和选择排序，刚准备写插入排序已经11点了。开摆！
	
	
## 2022-3-15  
早上实验室老师突然通知要检查项目进度，下午准备把项目进度再推进下。
	
	
***
#### 力扣每日一题2044. 统计按位或能得到最大值的子集数目  
给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。

如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。

对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。  
	
这道题还蛮有意思的，因为对位运算不熟悉，一开始就没看明白题目。百度才get到【按位或】的意思。
	
> 按位或运算符（|）
> 参加运算的两个数，按二进制位进行“或”运算。
> 
> 运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。
> 
> 即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。
> 
> 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

开始动手解题的时候也遇到了几个需要解决的问题：  
	
1.如何快速找到可能得到的最大值，并且找到必须存在的关键元素。  
	
2.得到关键元素后，如何快速统计出子集的数量。  
	
想了快1个小时想不出来怎么解。看题解才发现涉及到回溯和动态规划。用dfs似乎也能解但是没想太明白。准备先搁置这道题，后续再回来解决。

	
	
#### 之前没解决的题#面试题 01.01 判定字符是否唯一
	
解题思路：简单使用unorderedmap直接就出来了。。5个月前还不会用哈希表
	
	
	
#### 之前没解决的题[128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)  

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

	
提交错误原因：

> 1.没考虑到输入为[]  
> 
> 2.输入为[1,2,0,1]，没考虑到重复数字的情况。  

解答思路：
用unordered_map去重，再用priority_queue排序，最后用while循环判断最长的序列。

```c++
while(q.size()!=0){
    if(q.top()-last_num == 1){
	cnt_tmp++;
    }
    else{
	if(cnt_tmp>longCnt){
	    longCnt = cnt_tmp;
	}
	cnt_tmp = 1;
    }
    last_num = q.top();
    q.pop();
}
```

优化解题思路：不需要用unordered_map+priority_queue，只需要使用unordered_set即可。
> 那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。

```c++
for(int num : hash_set){
	if(!hash_set.count(num-1)){
		cnt_tmp = 1;
		int current_num = num;
		while(hash_set.count(current_num+1)){
			cnt_tmp++;
			current_num++;
		}
		longCnt = max(longCnt,cnt_tmp);
	}
}
```

#### 之前没解决的题[652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)  

给定一棵二叉树 root，返回所有重复的子树。  

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。  

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。  

难点与解决方案：  
	
> 1.如何识别相同的子树——借用unordered_set。
> 
> 2.如何把链表写入哈希表中——转换成字符串写入
>
> 3.int怎么转成字符串？ —— 使用#include<string>头文件中自带函数to_string完成转换
