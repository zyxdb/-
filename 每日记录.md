## 2022-3-14

参加了牛客的华为研发工程师编程题，熟悉了下写题的黑盒模式（自己负责管理输入输出、导入各种库）。写了3道题，都写出来了。


不足之处有

> 1.优先级队列 priority_queue的英文拼写老是忘记。使用的声明为 priority_queue<int,vector<int>,greater<int>>;

> 2.算法的头忘了。 #algorithm

***
解决的3道题

#### 1.某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。
小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。

解决思路：设一个变量num记录当前空瓶数，设一个变量res记录最终答案（初始化为0）。

```c++
while(num >2){  
	res+=num/3;  
	num = num/3 + num%3;  
}
```

当循环结束，如果num=2时，res++（因为可以向老板借一瓶）  

#### 2.明明生成了N个1到500之间的随机整数。请你删去其中重复的数字，即相同的数字只保留一个，把其余相同的数去掉，然后再把这些数从小到大排序，按照排好的顺序输出。

解决思路：第一反应就是用哈希表+优先级队列去解决。哈希表保证数据的唯一性，用优先级队列保证数据的有序性

#### 3.写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

解决思路： 因为输入的都是一个形如0xAA的字符串，只需要写一个for循环从字符串的尾部开始，转换成十进制并累计即可。
```c++
for(int i = size-1;i>=2;i--){
	if(str[i] == 'A'){
		res += (pow(16,count)*10);//这里不用傻乎乎的写5个if，直接-55就行了
	}
	else if(str[i] == 'B'){
		res += (pow(16,count)*11);
	}
	else if(str[i] == 'C'){
		res += (pow(16,count)*12);
	}
	else if(str[i] == 'D'){
		res += (pow(16,count)*13);
	}
	else if(str[i] == 'E'){
		res += (pow(16,count)*14);
	}
	else if(str[i] == 'F'){
		res += (pow(16,count)*15);
	}
	else{
		int num = (int)(str[i]-'0');//这里一定要记得-‘0’
		res += (pow(16,count)*num);
	}
	count++;
}
```
***
#### 力扣每日一题599. 两个列表的最小索引总和

假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。
	
解决思路：还是哈希表一下子就解出来了。不用思考的题

***
看视频摆烂了会儿。开始自己手写十大排序算法，写了冒泡和选择排序，刚准备写插入排序已经11点了。开摆！
	
	
## 2022-3-15  
早上实验室老师突然通知要检查项目进度，下午准备把项目进度再推进下。
	
	
***
#### 力扣每日一题2044. 统计按位或能得到最大值的子集数目  
给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。

如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。

对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。  
	
这道题还蛮有意思的，因为对位运算不熟悉，一开始就没看明白题目。百度才get到【按位或】的意思。
	
> 按位或运算符（|）
> 参加运算的两个数，按二进制位进行“或”运算。
> 
> 运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。
> 
> 即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。
> 
> 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

开始动手解题的时候也遇到了几个需要解决的问题：  
	
1.如何快速找到可能得到的最大值，并且找到必须存在的关键元素。  
	
2.得到关键元素后，如何快速统计出子集的数量。  
	
想了快1个小时想不出来怎么解。看题解才发现涉及到回溯和动态规划。用dfs似乎也能解但是没想太明白。准备先搁置这道题，后续再回来解决。

	
	
#### 之前没解决的题#面试题 01.01 判定字符是否唯一
	
解题思路：简单使用unorderedmap直接就出来了。。5个月前还不会用哈希表
	
	
	
#### 之前没解决的题[128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)  

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

	
提交错误原因：

> 1.没考虑到输入为[]  
> 
> 2.输入为[1,2,0,1]，没考虑到重复数字的情况。  

解答思路：
用unordered_map去重，再用priority_queue排序，最后用while循环判断最长的序列。

```c++
while(q.size()!=0){
    if(q.top()-last_num == 1){
	cnt_tmp++;
    }
    else{
	if(cnt_tmp>longCnt){
	    longCnt = cnt_tmp;
	}
	cnt_tmp = 1;
    }
    last_num = q.top();
    q.pop();
}
```

优化解题思路：不需要用unordered_map+priority_queue，只需要使用unordered_set即可。
> 那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。

```c++
for(int num : hash_set){
	if(!hash_set.count(num-1)){
		cnt_tmp = 1;
		int current_num = num;
		while(hash_set.count(current_num+1)){
			cnt_tmp++;
			current_num++;
		}
		longCnt = max(longCnt,cnt_tmp);
	}
}
```

#### 之前没解决的题[652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)  

给定一棵二叉树 root，返回所有重复的子树。  

对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。  

如果两棵树具有相同的结构和相同的结点值，则它们是重复的。  

难点与解决方案：  
	
> 1.如何识别相同的子树——借用unordered_set。
> 
> 2.如何把链表写入哈希表中——转换成字符串写入
>
> 3.int怎么转成字符串？ —— 使用#include<string>头文件中自带函数to_string完成转换
	
提交错误原因：

> 1.输入用例为[0,0,0,0,null,null,0,null,null,null,0]。转换成字符串时没去分辨左右子树，导致如果链表val全为同一值会识别错误。
> 	
> 于是在左子树、右子树、root的值之间分别都加上了“，”作分割
```c++
string TreeNode2str(TreeNode* root) {
	if (root == nullptr) return "";
	string str = "";
	str+=TreeNode2str(root->left);
	str += ",";
	str += TreeNode2str(root->right);
	str += ",";
	str+=to_string(root->val);

	return str;
}
```

> 
> 2.这道题最好别用中序遍历，因为无法处理对称问题
```c++
           0                       0
       1       0               0       1
              1   1          1  1
```
	
> 3.超出时间限制。代码需要再进一步优化。之前2个函数过于臃肿，缩减成一个函数。

## 2022-3-16  

#### [归并排序](https://mp.weixin.qq.com/s/7_jsikVCARPFrJ6Hj1EYsg) 

参照思路，自己动手写了一遍归并排序。代码还是有点臃肿，但是思路基本掌握了。回过头可能还得反复复习这块知识。

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) 
#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) 

都是简单题，没什么需要写的。
	
## 2022-3-17  
	
#### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/) 
	
给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。  

还蛮有意思的一道题，在labuladong关于归并排序的使用方式中看到的，可以用归并排序的思想做的一道题。苦思冥想很久也没想出成熟的解法，看了下解题思路，理解也花了很久时间。
	
解题思路：
	
1.在nums数组中所有数均不同的情况下，手写归并排序，统计某个数右移了多少次即可得到右侧小于当前元素的个数。(画图时画错了，4应该是右移了2次)
	
![图片描述](/2022-3-16%20.jpg)
	
2.在有相同数的情况下，使用记录当前位置与最初位置对应关系的哈希表来作唯一标识。
	
这道题写了2天，结果提交发现还是出错。暂时先搁置，等后面再来做吧。
	

#### [720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/) 
	
学习收获：

1. C++删除string最后一个字符的几种方法
	
```c++
//方法一：使用substr()
str = str.substr(0, str.length() - 1);

//方法二：使用erase()
str.erase(str.end() - 1);

//方法三：使用pop_back()
str.pop_back();
```

## 2022-3-18  
	
#### [2043. 简易银行系统](https://leetcode-cn.com/problems/simple-bank-system/) 
	
绷不住了，这么简单的每日一题我居然还提交错了2次。细看才发现，原来一个条件应该使用【或】（||）的，用成了【与】（&&）。还是粗心啊，唉。、、
	
#### [快速排序](https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ) 
	
1.C++中生成随机数的方式（利用C++11新特性，需要#include<random>）
	
```c++
//engine 是一个带状态的随机数生成器，在预定义的范围 [min, max] 以内生成随机数
//为了增加随机性，我们可以使用时间戳作为 engine 的随机数种子
default_random_engine generator(time(NULL));
//unifrom_int (所有的整数倍都被以相等的概率产生)
uniform_int_distribution<int> distribution(0, nums.size());
//想获得一个随机数，要用一个随机引擎为参数调用distribution来产生一个随机数
int random_num = distribution(generator);
```
	
2.为了防止快排最差情况变成冒泡排序，最好在排序之前打乱数组数据。
	
3.快排的左指针和右指针的边界条件需要考虑很清楚。partition函数到时候需要回过头加强下记忆。

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) 
	
1.用快速排序的思想做。重写了遍快排，还是有点不熟练，后续要再多写写。
	
2.写快排的时候，如果是要排成从大到小的情况，和从小到大的情况有一些不一样，需要注意。

## 2022-3-19  

#### [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/) 
	
> 在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。
> 
> 如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：
> 
> ages[y] <= 0.5 * ages[x] + 7
> 
> ages[y] > ages[x]
> 
> ages[y] > 100 && ages[x] < 100
> 
> 否则，x 将会向 y 发送一条好友请求。
> 
> 注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。
> 
> 返回在该社交媒体网站上产生的好友请求总数。

几个月前没做出来的题，现在重拾起来做。总共提交了5次才通过。
	
解答思路是先把数组排序（手写快排，温习昨天的内容），然后建立左右指针，使用二分法找左右指针的上下限。
	
#### [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/) 
	
本来一个很简单的前序遍历的题，我硬生生的想复杂了，拖了很久才写出来。
	
学到了一个很好用的函数to_string()，可以把数字转换成字符串的，这样还省去了+'0'的麻烦，也可以很轻松处理小数和超过100多的数值。
	
## 2022-3-20  
	
#### [2039. 网络空闲的时刻](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/) 
	
一道图论的题。想到的思路是用bfs找到所有分服务器去往主服务器的最短路径，然后找到其中最长的那个，再找出这条路径上一次发送数据的时间，两者相加再+1就是最终答案。
	
第一次提交错误：
鬼使神差想成了图论用dfs解决。结果dfs函数陷入了无限循环（i=5,i=7,i=5,i=7....）
	
```c++
int dfs(int i){
	if(i == 0) return 0;
	if(min_road.count(i)) return min_road[i];
	int min = INT_MAX;
	vector<int> roads = road[i];
	for(int i:roads){
		int tmp = dfs(i);
		min = tmp<min?tmp:min;
		if(min == 0) break;
	}
	min_road[i] = 1+min;
	return 1+min;
}
```
2.改用bfs解决，新增了一个stack防止重复的数被遍历。鬼知道之前咋想成dfs的...							  
							   
#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) 

之前写过的一道题，刚好今天每日一题用到了bfs，就又拿出来写写。
							   
***

vector添加元素（push_back()和emplace_back()）的区别
				       
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。
				       
push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；
				       
而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐
				       

## 2022-3-21
							   
#### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/) 			
							   
hashset记录要寻找的值。然后前序遍历树，递归寻找。解出来是随便解出来，但是效率好像不是很高。

***

asasfans项目，把master分支的代码更新到本地，然后与本地的代码进行合并。

合并后的代码原本一个buttom变成了imageview。成功改成ImageButton。

参考别人的代码，利用okhttp调用vtbmoe的api，获得json数据，利用handle解析数据。

在handle里利用gson解析数据生成对应的数据类bean，再自建一个数据类存储需要用到的数据（并且加上了是否储存过的布尔判断）。

## 2022-3-22  

#### [2038. 如果相邻两个颜色均相同则删除当前颜色](https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/) 	

意料之外的简单。看完题目描述我还以为会比较复杂，但是实际上一个哈希表进行滑窗就可以解决了（甚至用不到哈希表，数组就行其实）

***

稳功仪项目，解决2个问题

1.实时功率显示正确，但是平均功率和标准差显示有误。检查发现是因为之前定义的sum值，在每次【开始画线】的时候没有把值归零导致的。加上判断bug消除

2.画图持续过程中，整个程序都卡顿，尤其是在输入框中输入数据很明显。debug的时候发现因为完成一次发送操作可能要1秒多，估计是每隔一秒都有一次发送的操作，导致上一个发送操作还没完成，下一个发送操作就要执行了。。估计是线程堵塞了？

3.原先画图的x轴显示是一秒1个点，现在改成1秒显示2个点。
